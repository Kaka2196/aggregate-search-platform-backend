{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1754073042788556801",
        "title": "RabbitMQ一死信队列介绍和应用",
        "description": "介绍RabbitMQ死信队列的基本概念和其在项目中的应用",
        "content": "## 前言\n最近在做一个BI项目，用到了RabbitMQ异步化生成图表，同时还添加了死信队列处理无法被消费者正常消费的消息。于是便有了这篇文章，下面由我带大家介绍RabbitMQ的死信队列和其在项目中的应用吧。\n\n## 死信和死信队列的概念\n什么是死信？简单来说就是无法被消费和处理的消息。一般生产者将消息投递到broker或者queue，消费者直接从中取出消息进行消费。但有时因为某些原因导致消息不能被消费，导致消息积压在队列中，这样的消息如果没有后续的处理就会变成死信，那么专门存放死信的队列就是死信队列。\n\n## 什么是死信交换机？\n那么什么是死信交换机呢？死信交换机是指专门将死信路由到死信队列的交换机。\n\n## 产生死信的原因\n根据官方文档，我们发现一般有三种场景会产生死信。\n\n![87aceca905ab9eb09b3f08bbfbaf414.png](https://pic.code-nav.cn/post_picture/1608639807578177538/zk6hcBK7-87aceca905ab9eb09b3f08bbfbaf414.png)\n1. 消息超过TTL，即消息过期\n2. 消息被nack或reject，且不予重新入队\n3. 队列达到最大长度\n\n## 死信队列实战和应用\n死信队列的应用并不难，无非就是多定义了一个交换机、routingKey和队列罢了。在声明普通队列时传入Map参数，往Map中put死信队列名称、死信routingKey、消息TTL等参数即可完成死信自动投递到死信队列的流程。通过如下代码即可绑定普通队列和死信交换机了，而且还能设置routingKey和队列长度等参数，无需像传统的那样通过channel绑定。\n\n\n```java\nMap<String, Object> arguments = new HashMap<>(); // 过期时间 arguments.put(\"x-message-ttl\", 10000); // 正常队列设置死信交换机 arguments.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE); // 设置死信routingKey arguments.put(\"x-dead-letter-routing-key\", \"lisi\"); // 设置正常队列的长度限制 arguments.put(\"x-max-length\", 10);\n```\n\n流程图：\n\n![image-20240107185524304.png](https://pic.code-nav.cn/post_picture/1608639807578177538/1axzGMHp-image-20240107185524304.png)\n\n生产者Producer：\n\npublic class Producer {\n    // 普通交换机名称\n    public static final String NORMAL_EXCHANGE = \"normal_exchange\";\n\n    public static void main(String[] args) throws IOException {\n        Channel channel = RabbitMQUtils.getChannel();\n        //死信消息 设置TTL时间\n        AMQP.BasicProperties properties = new AMQP.BasicProperties()\n                .builder().expiration(\"10000\").build();\n\n        // 延迟消息\n        for (int i = 0;i < 10;i++) {\n            String message = i + \"info\";\n            channel.basicPublish(NORMAL_EXCHANGE, \"zhangsan\", properties, message.getBytes());\n        }\n    }\n}\n\n​\n普通队列消费者C1：\n\n```java\npublic class Consumer01 {\n    // 普通交换机名称\n    public static final String NORMAL_EXCHANGE = \"normal_exchange\";\n    // 死信交换机名称\n    public static final String DEAD_EXCHANGE = \"dead_exchange\";\n    // 普通队列名称\n    public static final String NORMAL_QUEUE = \"normal_queue\";\n    // 死信队列名称\n    public static final String DEAD_QUEUE = \"dead_queue\";\n\n    public static void main(String[] args) throws IOException {\n        Channel channel = RabbitMQUtils.getChannel();\n        // 声明死信和普通交换机，类型为direct\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n        // 声明普通队列\n        Map<String, Object> arguments = new HashMap<>();\n        // 过期时间\n        arguments.put(\"x-message-ttl\", 10000);\n        // 正常队列设置死信交换机\n        arguments.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE);\n        // 设置死信routingKey\n        arguments.put(\"x-dead-letter-routing-key\", \"lisi\");\n        // 设置正常队列的长度限制\n        arguments.put(\"x-max-length\", 10);\n\n        // 声明普通队列\n        channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);\n        // 声明死信队列\n        channel.queueDeclare(DEAD_QUEUE, false, false, false, null);\n\n        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, \"zhangsan\");\n        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, \"lisi\");\n        System.out.println(\"consumer01等待接收消息\");\n\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            String msg = new String(message.getBody(), \"UTF-8\");\n            if (msg.equals(\"info5\")) {\n                System.out.println(\"consumer01接收的消息：\" + new String(message.getBody()));\n                System.out.println(msg + \"：此消息是被拒绝的\");\n                channel.basicReject(message.getEnvelope().getDeliveryTag(), false); //拒绝此消息并不放回普通队列\n            } else {\n                System.out.println(\"consumer01接收的消息：\" + new String(message.getBody()));\n                channel.basicAck(message.getEnvelope().getDeliveryTag(), false);\n            }\n        };\n\n        CancelCallback cancelCallback = consumerTag -> {\n            System.out.println(\"C1取消消息\");\n        };\n        channel.basicConsume(NORMAL_QUEUE, false, deliverCallback, cancelCallback);\n    }\n}\n```\n\n死信队列消费者C2\n\n```java\npublic class Consumer02 {\n    // 死信队列名称\n    public static final String DEAD_QUEUE = \"dead_queue\";\n\n    public static void main(String[] args) throws IOException {\n        Channel channel = RabbitMQUtils.getChannel();\n        System.out.println(\"consumer02等待接收消息\");\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            System.out.println(\"consumer02接收的消息：\" + new String(message.getBody()));\n        };\n\n        CancelCallback cancelCallback = consumerTag -> {\n            System.out.println(\"C2取消消息\");\n        };\n        channel.basicConsume(DEAD_QUEUE, true, deliverCallback, cancelCallback);\n    }\n}\n```\n依次启动生产者，和两个消费者，并停掉普通队列的消费者，我们发现生产者发送的消息被死信队列消费者C2给接收了。\n\n![f0921a45fdc93175d4b914af3302340.jpg](https://pic.code-nav.cn/post_picture/1608639807578177538/m8risyQD-f0921a45fdc93175d4b914af3302340.jpg)\n\n> 在上面的代码中，我在普通队列中设置了消息的TTL为5s，但是我又在生产者设置发送的消息TTL为10s，那么RabbitMQ会以哪个为准呢？其实RabbitMQ会以较短的TTL为准\n\n\n## BI项目添加死信队列\n### 声明交换机、队列和routingKey的配置类\n\n```java\n@Configuration\npublic class TtlQueueConfig {\n    private final String COMMON_EXCHANGE = \"bi_common_exchange\"; // 普通交换机名称\n    private final String COMMON_QUEUE = \"bi_common_queue\"; // 普通队列名称\n    private final String DEAD_LETTER_EXCHANGE = \"bi_dead_letter_exchange\"; // 死信交换机名称\n    private final String DEAD_LETTER_QUEUE = \"bi_dead_letter_queue\"; // 死信队列名称\n    private final String COMMON_ROUTINGKEY = \"bi_common_routingKey\"; // 普通routingKey\n    private final String DEAD_LETTER_ROUTINGKEY = \"bi_dead_letter_routingKey\"; // 死信routingKey\n\n    // 普通交换机\n    @Bean(\"commonExchange\")\n    public DirectExchange commonExchange() {\n        return new DirectExchange(COMMON_EXCHANGE);\n    }\n\n    // 死信交换机\n    @Bean(\"deadLetterExchange\")\n    public DirectExchange deadLetterExchange() {\n        return new DirectExchange(DEAD_LETTER_EXCHANGE);\n    }\n\n    // 普通队列\n    @Bean(\"commonQueue\")\n    public Queue commonQueue() {\n        Map<String, Object> map = new HashMap<>(3);\n        map.put(\"x-message-ttl\", 20000);\n        map.put(\"x-dead-letter-exchange\", DEAD_LETTER_EXCHANGE);\n        map.put(\"x-dead-letter-routing-key\", DEAD_LETTER_ROUTINGKEY);\n        return QueueBuilder.durable(COMMON_QUEUE).withArguments(map).build();\n    }\n\n    // 死信队列\n    @Bean(\"deadLetterQueue\")\n    public Queue deadLetterQueue() {\n        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();\n    }\n\n    @Bean\n    public Binding commonQueueBindingCommonExchange(@Qualifier(\"commonQueue\") Queue commonQueue,\n                                                    @Qualifier(\"commonExchange\") DirectExchange commonExchange) {\n        return BindingBuilder.bind(commonQueue).to(commonExchange).with(COMMON_ROUTINGKEY);\n    }\n\n    @Bean\n    public Binding deadQueueBindingDeadExchange(@Qualifier(\"deadLetterQueue\") Queue deadLetterQueue,\n                                                @Qualifier(\"deadLetterExchange\") DirectExchange deadLetterExchange){\n        return BindingBuilder.bind(deadLetterQueue).to(deadLetterExchange).with(DEAD_LETTER_ROUTINGKEY);\n    }\n}\n```\n\n### 普通消费者（负责异步生成图表信息）\n\n```java\n@Configuration\npublic class TtlQueueConfig {\n    private final String COMMON_EXCHANGE = \"bi_common_exchange\"; // 普通交换机名称\n    private final String COMMON_QUEUE = \"bi_common_queue\"; // 普通队列名称\n    private final String DEAD_LETTER_EXCHANGE = \"bi_dead_letter_exchange\"; // 死信交换机名称\n    private final String DEAD_LETTER_QUEUE = \"bi_dead_letter_queue\"; // 死信队列名称\n    private final String COMMON_ROUTINGKEY = \"bi_common_routingKey\"; // 普通routingKey\n    private final String DEAD_LETTER_ROUTINGKEY = \"bi_dead_letter_routingKey\"; // 死信routingKey\n\n    // 普通交换机\n    @Bean(\"commonExchange\")\n    public DirectExchange commonExchange() {\n        return new DirectExchange(COMMON_EXCHANGE);\n    }\n\n    // 死信交换机\n    @Bean(\"deadLetterExchange\")\n    public DirectExchange deadLetterExchange() {\n        return new DirectExchange(DEAD_LETTER_EXCHANGE);\n    }\n\n    // 普通队列\n    @Bean(\"commonQueue\")\n    public Queue commonQueue() {\n        Map<String, Object> map = new HashMap<>(3);\n        map.put(\"x-message-ttl\", 20000);\n        map.put(\"x-dead-letter-exchange\", DEAD_LETTER_EXCHANGE);\n        map.put(\"x-dead-letter-routing-key\", DEAD_LETTER_ROUTINGKEY);\n        return QueueBuilder.durable(COMMON_QUEUE).withArguments(map).build();\n    }\n\n    // 死信队列\n    @Bean(\"deadLetterQueue\")\n    public Queue deadLetterQueue() {\n        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();\n    }\n\n    @Bean\n    public Binding commonQueueBindingCommonExchange(@Qualifier(\"commonQueue\") Queue commonQueue,\n                                                    @Qualifier(\"commonExchange\") DirectExchange commonExchange) {\n        return BindingBuilder.bind(commonQueue).to(commonExchange).with(COMMON_ROUTINGKEY);\n    }\n\n    @Bean\n    public Binding deadQueueBindingDeadExchange(@Qualifier(\"deadLetterQueue\") Queue deadLetterQueue,\n                                                @Qualifier(\"deadLetterExchange\") DirectExchange deadLetterExchange){\n        return BindingBuilder.bind(deadLetterQueue).to(deadLetterExchange).with(DEAD_LETTER_ROUTINGKEY);\n    }\n}\n\n普通消费者（负责异步生成图表）\n\n@Component\n@Slf4j\npublic class BIMessageConsumer {\n    @Resource\n    private ChartService chartService;\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Resource\n    private AIManager aiManager;\n\n    @Resource\n    RedisTemplate<String, Object> redisTemplate;\n\n    // 制定消费者监听哪个队列和消息确认机制\n    @SneakyThrows\n    @RabbitListener(queues = {\"bi_common_queue\"}, ackMode = \"MANUAL\")\n    public void receiveMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) {\n        log.info(\"receiveMessage is {}\", message);\n        if(StringUtils.isBlank(message)) {\n            // 如果失败，消息拒绝\n            channel.basicNack(deliveryTag, false, false);\n            log.info(\"消息为空拒绝接收\");\n            log.info(\"此消息正在被转发到死信队列中\");\n        }\n\n        long chartId = Long.parseLong(message);\n        Chart chart = chartService.getById(chartId);\n        if (chart == null) {\n            channel.basicNack(deliveryTag, false, false);\n            log.info(\"图标为空拒绝接收\");\n            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR, \"图表为空\");\n        }\n\n        // 先修改图表任务状态为“执行中”。等执行成功后，修改为“已完成”、保存执行结果；执行失败后，状态修改为“失败”，记录任务失败信息。\n        Chart updateChart = new Chart();\n        updateChart.setId(chart.getId());\n        updateChart.setStatus(\"running\");\n        boolean b = chartService.updateById(updateChart);\n        if (!b) {\n            channel.basicNack(deliveryTag, false, false);\n            handlerChartUpdateError(chart.getId(), \"更新图表执行状态失败\");\n            return;\n        }\n        // 调用AI\n        String result = aiManager.doChat(CommonConstant.BI_MODEL_ID, buildUserInput(chart));\n        String[] splits = result.split(\"【【【【【\");\n        if (splits.length < 3) {\n            channel.basicNack(deliveryTag, false, false);\n            handlerChartUpdateError(chart.getId(), \"AI生成错误\");\n            return;\n        }\n        String genChart = splits[1].trim();\n        String genResult = splits[2].trim();\n        Chart updateChartResult = new Chart();\n        updateChartResult.setId(chart.getId());\n        updateChartResult.setGenChart(genChart);\n        updateChartResult.setGenResult(genResult);\n        updateChartResult.setStatus(\"succeed\");\n        boolean updateResult = chartService.updateById(updateChartResult);\n        if (!updateResult) {\n            channel.basicNack(deliveryTag, false, false);\n            handlerChartUpdateError(chart.getId(), \"更新图表成功状态失败\");\n        }\n        Long userId = chartService.queryUserIdByChartId(chartId);\n        String myChartId = String.format(\"lingxibi:chart:list:%s\", userId);\n        redisTemplate.delete(myChartId);\n\n        // 如果任务执行成功，手动执行ack\n        channel.basicAck(deliveryTag, false);\n    }\n\n\n    private void handlerChartUpdateError(long chartId, String execMessage) {\n        Chart updateChartResult = new Chart();\n        updateChartResult.setId(chartId);\n        updateChartResult.setStatus(\"failed\");\n        updateChartResult.setExecMessage(execMessage);\n        boolean updateResult = chartService.updateById(updateChartResult);\n        if (!updateResult) {\n            log.error(\"更新图表失败状态失败\" + chartId + \",\" + execMessage);\n        }\n    }\n\n    /**\n     * 构建用户输入\n     * @param chart\n     * @return\n     */\n    private String buildUserInput(Chart chart) {\n        String goal = chart.getGoal();\n        String chartType = chart.getChartType();\n        String csvData = chart.getChartData();\n\n        // 构造用户输入\n        StringBuilder userInput = new StringBuilder();\n        userInput.append(\"分析需求：\").append(\"\\n\");\n        // 拼接分析目标\n        String userGoal = goal;\n        if (StringUtils.isNotBlank(chartType)) {\n            userGoal += \",请使用\" + chartType;\n        }\n        userInput.append(userGoal).append(\"\\n\");\n        userInput.append(\"原始数据：\").append(\"\\n\");\n        // 压缩后的数据\n\n        userInput.append(csvData).append(\"\\n\");\n        return userInput.toString();\n    }\n}\n```\n### 死信队列消费者（负责处理死信）\n收到死信后我是直接确认了，这种方式可能不好，你也可以换成其他方式比如重新入队，或者写入数据库并打上日志等等。\n\n```java\n@Component\n@Slf4j\npublic class TtlQueueConsumer {\n    @Resource\n    BIMessageProducer biMessageProducer;\n\n    @SneakyThrows\n    @RabbitListener(queues = \"bi_dead_letter_queue\", ackMode = \"MANUAL\")\n    public void doTTLMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) {\n        log.info(\"已经接受到死信消息：{}\", message);\n        biMessageProducer.sendMessage(message);\n        channel.basicAck(deliveryTag, false);\n    }\n}\n```\n如果我的文章对你有帮助的话，不妨给我点个赞呗，我会持续带来不一样的内容。如果对Java相关知识感兴趣的话，可以关注我，带你走进Java的世界。\n\n​",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1608639807578177538/Gz1wdtU7-OIP (1).jpg",
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 64,
        "thumbNum": 4,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608639807578177538",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-04T09:22:57.000+00:00",
        "updateTime": "2024-02-19T08:01:00.000+00:00",
        "user": {
          "id": "1608639807578177538",
          "planetCode": "24506",
          "userName": "吃遍全国汉堡\uD83C\uDF54",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/hib5bbuJu0U3DnxEuGVHEiaGEQr55285A2zaluuxopzXxX5xXFwwfbia7uZcbzpQ5HUDIBeZsIq7VMtfdo1icbL86w/132",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [
            "Java"
          ],
          "place": "江苏淮安",
          "birthday": "2003-10-15",
          "school": "",
          "major": "计算机科学与技术",
          "education": "本科",
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "实习",
          "github": null,
          "blog": "https://blog.csdn.net/xyendjsj?spm=1000.2115.3001.5343",
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-07-04T00:04:09.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-30T01:43:11.000+00:00",
          "updateTime": "2024-02-08T04:37:32.000+00:00"
        },
        "tags": [
          "文章",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1753458702704189442",
        "title": "柒夭八股：缓存击穿的解决方案",
        "description": "缓存击穿的解决方案",
        "content": "\n\n这个主要是最近准备八股文缓存专题时做的笔记，主要是对于缓存击穿的解决方案，目前总结起来大概三种\n分别是缓存预热、分布式锁以及永不过期，这三种这里做了详细的讲述，看看到过年前能不能把缓存专题给整完，fighting！\n\n\n\n## 什么是缓存击穿？\n\n![image.png](https://pic.code-nav.cn/zhishizhushou/post/1748982812024778754/eDyIAEnf-image.png)\n\n\n缓存击穿是指在高并发系统中，一个热点数据缓存的过期或者缓存中的热点数据不存在，导致大量并发请求直接访问数据库，从而给数据库造成巨大压力，甚至宕机的现象。\n说具体点就是当某个热点数据在缓存中过期了，如果此时有大量并发请求同时访问这个数据，由于缓存中这个数据不存在，其所有的请求都会直接访问数据库，从而导致数据库压力急剧增加。\n\n\n\n\n## 如何解决缓存击穿？\n\n一般来说，解决缓存击穿的方法主要有三种：\n1. 加分布式锁\n2. 热点数据预加载（缓存预热）\n3. 热点数据永不过期\n\n\n\n### 1. 分布式锁\n\n\n\n这里我们来逐步进行分析，分析如何通过互斥锁的方式来解决缓存击穿问题、\n\n\n\n\n1、查询缓存不存在查询数据库\n\n\n\n\n这个就是第一版的解决方案，也是我们对于普通数据的缓存方案，这个方案首先查询缓存中对应的数据是否存在，如果不存在就请求数据库，数据库中存在就将当前数据写入到缓存中，这个方案的问题也比较明显：如果缓存中热点数据的缓存过期或者被删除，大量的请求将会打到数据库，从而导致数据库压力较大。\n\n伪代码如下：\n```java\npublic String queryInfo(String id){\n    // 1. 从缓存中获取对应的数据\n    String cacheData = cache.get(id);\n    // 2.判断获取的数据是否为空\n    if(cacheData == null){\n        // 查询缓存数据为空，，查询数据库\n        String dbData = db.queryById(id);\n        if(dbData != null){\n            cache.set(id,data);\n            cacheData = dbData;\n        }\n    }\n    // 返回数据\n\treturn cacheData; \n}\n```\n\n\n\n2、通过分布式互斥锁的方案降低数据库压力\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1627889630378479618/rMVY0Sx2-image.png)\n\n\n\n分布式锁的解决方案就是保证只有一个请求可以访问数据库，其他需要访问数据库的请求等待结果。这样的话可以避免大量的请求同时访问数据库。\n\n这个主要是在原有的基础上进行一定的调整，即限制对于数据库的请求，每次只有一个请求可以访问数据库，这种方案可以有效地避免缓存击穿问题，因为只有一个线程可以在同一时间内查询数据库，其他线程则需要等待，这样的话就不会同时穿透到数据库。\n其主要在原有的基础上进行修改，伪代码如下：\n\n```java\npublic String queryInfo(String id){\n    // 1. 从缓存中获取对应的数据\n    String cacheData = cache.get(id);\n    // 2.判断获取的数据是否为空\n    if(cacheData == null){\n        // 查询缓存数据为空，，查询数据库\n        Lock lock = getLock(id);\n        lock.lock();\n        try{\n            String dbData = db.queryById(id);\n            if(dbData != null){\n                cache.set(id,data);\n                cacheData = dbData;\n            }\n        }finally{\n            lock.unlock();\n        }\n    }\n    // 返回数据\n\treturn cacheData; \n}\n```\n但是这样有一个弊端，那就是获取分布式锁的请求，都会执行一次查询数据库的请求，然后将查询结果更新到缓存中去。但是从理论上来说，只有第一次加载数据库记录的请求是有效的。\n这种情况会导致以下两个问题的发生：\n1. 海量的用户获取锁之后都查询数据库，这样的话会造成数据库性能的浪费，因为如此多的请求当中，只有第一次的查询请求是有效的，其他的查询请求都是可以避免的。\n2. 查询数据库过多的话可能会导致用户响应时间变长，接口吞吐量下降等情况。\n\n所以，针对以上情况，可以采用双重判定锁的方式来进行优化。\n![image.png](https://pic.code-nav.cn/zhishizhushou/post/1748982812024778754/rHtVixrB-image.png)\n双重判定锁的逻辑很简单，如下图所示，在查询数据库前，再次查询一下缓存，查看缓存中是否存在对应的数据，如果存在，则直接返回，不存在才去查询数据库。\n\n\n根据以上情况，其伪代码如下：\n```Java\npublic String queryInfo(String id){\n    // 1. 从缓存中获取对应的数据\n    String cacheData = cache.get(id);\n    // 2.判断获取的数据是否为空\n    if(cacheData == null){\n        // 查询缓存数据为空，，查询数据库\n        Lock lock = getLock(id);\n        lock.lock();\n        try{\n            // 进行缓存数据的二次判断\n            cacheData = cache.get(id);\n            if(cacheData == null){\n                // 缓存数据为空\n                String dbData = db.queryById(id);\n                if(dbData != null){\n                    cache.set(id,data);\n                    cacheData = dbData;\n                }\n            }\n        }finally{\n            lock.unlock();\n        }\n    }\n    // 返回数据\n\treturn cacheData; \n}\n```\n总结一下双重判断锁的逻辑\n1. 获取锁：在查询数据库之前，先尝试获取一个分布式锁，只有一个线程可以成功获取锁，其他线程等待。\n2. 查询数据库：如果双重判断锁确认缓存中不存在对应数据，那么执行查询数据库操作，获取数据。\n3. 将数据写入缓存：获取到数据之后，将数据写入缓存，并且设置一个合适的过期时间，以防止缓存永远不会被更新\n4. 释放锁：最后，释放获取的锁。使得其他线程可以继续使用这个锁。\n\n\n\n### 2. 热点数据预加载\n\n热点数据预加载，在活动开始之前，针对已知的热点数据从数据库加载到缓存中，这样的话可以避免海量的请求第一次访问热点数据的时候需要从数据库读取的流程，降低数据库的压力。可以极大地减少请求的响应时间，有效避免缓存击穿。\n\n\n### 3. 热点数据永不过期\n\n\n热点数据永不过期，指的是将可以预知的热点数据，在活动开始之前，将过期时间设置为 -1，这样的话就不会有缓存击穿的风险了。\n\n这个可以搭配热点数据预加载的方案一起实现，等到热点数据的时间结束之后，其数据的访问量降低了，通天阁后台任务的方案针对缓存设置过期时间，从而降低 Redis 存储的压力。\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 56,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1627889630378479618",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-02T16:41:47.000+00:00",
        "updateTime": "2024-02-19T04:19:59.000+00:00",
        "user": {
          "id": "1627889630378479618",
          "planetCode": "2784",
          "userName": "答案说明所有",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1627889630378479618/FYBQxM7a-Screenshot_20230717_113840.jpg",
          "gender": 1,
          "userProfile": "目标大厂，冲冲冲！",
          "userRole": "vip",
          "interests": [],
          "place": "广东",
          "birthday": "2023-05-12",
          "school": "广东石油化工学院",
          "major": "数据科学与大数据技术",
          "education": null,
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "大数据",
          "goal": "实习",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2025-02-27T11:51:43.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-21T04:35:07.000+00:00",
          "updateTime": "2024-01-04T07:44:31.000+00:00"
        },
        "tags": [
          "文章",
          "Redis",
          "面试"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1751857365470158849",
        "title": "有后端基础的前端转后端可以如何准备",
        "description": "目前有一定的Java后端基础知识和个人项目开发经验，前端工作一年，希望转后端。",
        "content": "目前有一定的Java后端基础知识和个人项目开发经验，前端工作一年，希望转后端。\n\n年后准备投简历，可以如何准备呢",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 52,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1656644181805797378",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-29T06:38:38.000+00:00",
        "updateTime": "2024-02-19T03:22:54.000+00:00",
        "user": {
          "id": "1656644181805797378",
          "planetCode": "22270",
          "userName": "ZJL",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epxcvXbR6INEDNaLjeBYZCNgT0OTxkNj0ZHYyAPW7jFpUjGqfVibvwguuAzj1lZfTPsvSSNYbGK9Sg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-05-16T11:29:04.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-05-11T12:55:26.000+00:00",
          "updateTime": "2024-01-29T06:34:49.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1751562414068867073",
        "title": "Vue3快速实现文件上传OSS",
        "description": "使用Vue3快速实现文件上传OSS",
        "content": "## 前言\n\n上传文件可以说是经典的需求了，在后台管理项目中随处可见。一般是由前端进行文件上传，然后再由后端去处理。可以选择把文件放到服务器上，但是随着后续文件增多，可能会对服务器的开销比较大，所以一般都采用OSS（Object Storage Service）对象存储服务，将我们的文件上传到第三方服务上，而我们只需要通过url去访问文件就可以了。那么今天就让我们来简单实现一下文件上传的功能吧。\n\n前端采用的是Element plus的upload组件，后端是NodeJS，采用阿里云的OSS服务进行存储。\n\n本文旨在实现上传功能，不考虑额外的功能（如文件尺寸限制）。\n\n## 前端\n\n前端引用一下组件，需要注意的是Element plus的upload组件提供了`action`配置项，填写请求URL就可以上传文件。\n\n![image-20240127194752126](http://cdn.t-terminal.icu/image-20240127194752126.png)\n\n但为了后期维护，我们一般都不采用`action`配置项,而是将其赋值为`#`,通过`http-request`封装我们自己的请求方法。\n\n通过组件库文档可知，我们的`doUpload`方法会获得一个options参数，我们来看看这个参数里有什么。\n\n![image-20240127195501774](http://cdn.t-terminal.icu/image-20240127195501774.png)\n\n可以看到通过options可以获取到组件的一些属性和方法，其中的`file`就是我们所需要上传的文件对象。将其解构出来通过`FormData`创建表单对象将文件通过我们封装的`upload`方法传输到后端。\n\n```typescript\nconst doUpload = async (options: any) => {\n  const { file } = options;\n  const formData = new FormData();\n  formData.append('file', file);\n  await upload(fileData);\n}\n```\n\n这里有个要点，因为是FormData表单对象，所以我们需要在请求头中设置`Content-Type`为`application/form-data`,这样后端才可以识别我们上传的文件，`upload`方法如下。\n\n```typescript\nconst headers = {\n  'Content-type': 'application/form-data'\n};\nexport function upload(params: any) {\n  return instance.post('/uploadImg', params, { headers });\n}\n```\n\n## 后端\n\n后端我们采用express进行编写。\n\n首先简单实现以下接口(注：由于我采用的是TypeScript，所以可以使用ESModule即import和export进行模块引入导出）。\n\n```typescript\nimport express from 'express';\nconst app = express();\n\napp.post('/uploadImg',(req, res) => {});\n\napp.listen(1300, () => {})\n```\n\n由于我们使用post请求,所以需要通过`body-parser`中间件对请求体的数据进行解析，使解析后的数据可用于后续的请求处理。\n\n通过`pnpm add body-parser `进行安装。\n\n```typescript\nimport bodyParser from 'body-parser';\napp.use(bodyParser.json({ limit: '10mb' }));\napp.use(bodyParser.urlencoded({ limit: '10mb', extended: true }));\n```\n\n以及还需要`cors`中间件解决跨域问题。\n\n`pnpm add cors`。\n\n```typescript\nimport cors from 'cors';\napp.use(cors());\n```\n\n最后，我们还需要`multer`中间件处理我们上传的文件，具体使用如下。\n\n`pnpm add multer`\n\n```typescript\nimport multer from 'multer';\nconst upload = multer({ dest: 'uploads/' }); // 指明文件的地址，即我们后端服务的uploads文件夹下，如果没有会创建。\n\n// 接口中进行文件解析\napp.post('/uploadImg', upload.single('file'), async (req: any, res: Response) => {})\n```\n\n这里的`upload.single`表明只处理上传数据中的`file`字段对应的数据,也就是我们之前`formData.append('file',file)`里的file文件，如果你设置的是其他字段如`fileData`，那么中间件就要写为`upload.single('fileData')`。\n\n我们可以通过`req.file`来获取处理好的文件，那么我们来看看打印一下这个`req.file`里有什么吧。\n\n![image-20240127202339246](http://cdn.t-terminal.icu/image-20240127202339246.png)\n\n可以看到里面包含了关于文件的一些信息，比如名称、类型、地址等，其中名称和地址会是我们所需要的参数。\n\n## OSS服务\n\n在阿里云的OSS文档里有提供文件上传的示例代码。\n\n![image-20240127202559887](http://cdn.t-terminal.icu/image-20240127202559887.png)\n\n进入后我们选择NodeJS的SDK参考，通过下图路径可以看到本文所需的示例代码。\n\n![image-20240127202748283](http://cdn.t-terminal.icu/image-20240127202748283.png)\n\n![image-20240127202803539](http://cdn.t-terminal.icu/image-20240127202803539.png)\n\n![image-20240127202824828](http://cdn.t-terminal.icu/image-20240127202824828.png)\n\n可以看到要使用OSS服务需要下载`ali-oss`第三方库。\n\n`pnpm add ali-oss`。\n\n```typescript\nimport * as OSS from 'ali-oss';\n\nconst client = new OSS.default({\n  // yourRegion填写Bucket所在地域。以华东1（杭州）为例，Regin填写为oss-cn-hangzhou。\n  region: 'oss-cn-hangzhou',\n  accessKeyId: '你的阿里云key',\n  accessKeySecret: '你的阿里云keyScerect',\n  // 填写Bucket名称，例如examplebucket。\n  bucket: '你阿里云OSS的桶名'\n});\n\nexport async function put(filename: string, fileData: File) {\n  try {\n    // 填写OSS文件完整路径和本地文件的完整路径。OSS文件完整路径中不能包含Bucket名称。\n    // 如果本地文件的完整路径中未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件。\n    const result = await client.put(filename, fileData);\n    return result;\n  } catch (e) {\n    console.log(e);\n  }\n}\n\n```\n\n以上就是完整的上传方法，只需要填写配置就行，其中`accessKeyId`和`accessKeySecret`可以通过个人面板的`AccessKey管理`创建获取。\n\n![image-20240127203447451](http://cdn.t-terminal.icu/image-20240127203447451.png)\n\n随后我们就可以在接口中进行调用，传入所需的`filename`和`fileData`。\n\n```typescript\nrouter.post('/uploadImg', upload.single('file'), async (req: any, res: Response) => {\n  const file = req.file;\n  const result = await put(file.originalname, file.path);\n  res.send({ code: 200, data: { fileName: result?.name, url: result?.url } });\n});\n```\n\n到现在为止，我们代码基本实现了，接下来看看成果吧。\n\n![(image-20240127204837906)](https://cdn.t-terminal.icu/%E4%B8%8A%E4%BC%A0%E6%BC%94%E7%A4%BA.gif)\n\n可以在阿里云的OSS中看到我们上传的文件。\n\n![(image-20240127204837906)](http://cdn.t-terminal.icu/image-20240127204837906.png)\n\n而在后端也可获取到接口返回的文件名和外链地址。\n\n![image-20240127205406324](http://cdn.t-terminal.icu/image-20240127205406324.png)\n\n## 总结\n\n以上就是通过Element Plus的Upload组件、NodeJS和阿里OSS服务实现的文件上传简单实现啦。我是花椒，如果你觉得我的文章还不错就给我点个赞吧~ 如果有什么错误也欢迎评论指正哦~",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 46,
        "thumbNum": 2,
        "favourNum": 2,
        "commentNum": 1,
        "priority": 0,
        "userId": "1623999012233351170",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-28T11:06:36.000+00:00",
        "updateTime": "2024-02-19T07:18:53.000+00:00",
        "user": {
          "id": "1623999012233351170",
          "planetCode": "1112",
          "userName": "吃她喵的花椒",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKxA9Pclq3rjCwn09uBHEhZ9TibBxYgibUP1gL7v6SSBlpGNrqg1lichvib58sLYzkhGR9ibuyam09WUUQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [
            "简历"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 100,
          "followeeNum": 1,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-11T02:41:47.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-10T10:55:11.000+00:00",
          "updateTime": "2024-01-29T01:42:20.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1751549389131751425",
        "title": "不要追逐最新的技术栈 ",
        "description": "如何面对层出不穷的新技术",
        "content": "\n![image-20240128150537374](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/typora/image-20240128150537374.png)\n\n我们在网上花费大量时间听到别人说我们的技术栈有问题、不好、过时或者诸如此类的说法。别理那些极客们——这（大概率上）不值得去切换。\n\nJavaScript 的社区十分喧嚣，并且可能具有强制性。我们接收到大量关于我们应当和不应当采用什么来开发网站的意见。\n\n当几乎每一篇关于JavaScript的深度分析文章都与你之前看到的建议相矛盾，同时还坚持认为你需要学习最新的热门技术时，你该如何做出选择呢？\n\n我的个人观点是，很多开发者常常通过切换到新的技术栈来延后开发那些用户真正想要并关注的功能，所以**最佳的技术栈就是你今天就可以利用它来创建出实用产品的那个**\n\n## 我们只是在建设网站\n\n你能构建的最快网站是基于全球CDN的HTML和CSS。我们在该网站上添加任何其他内容都会使其变慢——因此，当我们打算增加额外步骤时，必须确保权衡利弊后的价值确实值得。\n\n归根结底，我们选择何种技术来构建网站并不重要。有大量业务蒸蒸日上，利润令人瞠目，但很少有业务使用最先进的网络框架。\n\n事实上，它们中的大多数都在使用 jQuery。\n\n## 77%的网站仍在使用jQuery。\n\n在技术炒作的泡沫中，”jQuery已经死亡“。我们谈论它的时候，就好像它已经被完全抛弃多年，再也没有人使用它了。\n\n实际上，互联网上每4个网站中就有3个仍在使用jQuery。\n\n你今天能用jQuery创建一个很棒的网站吗？当然可以！而且人们确实这么做了！\n\n## 社交媒体炒作的泡沫很小\n\n在 Twitter、YouTube、Hacker News、Reddit等网络技术圈子里，可能会让我们对网络开发世界的真实面貌产生偏差。有影响力的技术人员相对较少！花了大量时间讨论技术前沿。说得好像每个人都在做新事物，每个人都抛弃了旧事物。\n\n但现实并非如此。这只是对网络技术极为痴迷的书呆子在谈论的爱好。当然，他们也在生产中使用这些尖端技术，但他们只是例外，而不是普遍现象。\n\n社交媒体的 FoMO （注1）仍然对实际的产品交付构成威胁。\n\n## 如果你创建的东西很酷，工具就无关紧要了。\n\n如果你开发的网络应用程序让人们喜欢使用并愿意付费，那么你用什么工具来开发它并不重要。重要的是，你能把你的想法从头脑中解放出来，变成一个可以运行的应用程序。不管你是用 Java、.Net、Node、Ruby on Rails 还是 Dreamweaver 构建的，这都不重要。\n\n不要让那些在 Twitter 上发表权威言论的人，让你对自己使用什么构建应用程序感到自卑。重要的是，你创建了一些东西。\n\n## 何时切换才有意义？\n\n当有正当理由重建整个应用程序时，这个理由会相当明显和令人信服。例如重构之前在 IE6 上的内网，就有大量不得不做技术栈切换的安全和功能理由。\n\n但是，花几个月时间从 Node 切换到 Rust，就能让页面加载缩短 50 毫秒？这并不能产生足够的影响，也不值得为此付出代价。\n\n## 最好的技术堆栈就是你正在使用的技术。\n\n技术只是一种工具，它的作用只是将创意传递给人们，让他们使用、享受并（希望）为我们用它打造的东西买单。\n\n除此之外，除非你的工作就是制造工具，否则花在工具上的额外注意力就是一种业余爱好。业余爱好是美好的，它们推动了网络的发展，我们需要站在最前沿的人去尝试，但**你没有义务因为你当前的堆栈似乎不再时髦而改变你为网络构建的方式。**\n\n我们从事这一领域的目的是为现实中的人们解决实际问题。剩下的就是细节了。\n\n## 备注\n\n1. 什么是FoMO\n\n害怕缺席（Fear of Missing Out）是一种普遍存在的现代现象，其特点是担心他人可能正在享受自己缺席的有益体验。它通常出现在社会事件、聚会或活动的背景下，由于害怕不被接纳或被冷落而加剧。\n\nFoMO 的主要方面包括\n\n1. **社交媒体的影响：** 社交媒体平台的兴起在很大程度上助长了 FoMO。在 Facebook、Instagram 或 Twitter 等平台上看到他人精心策划的、看似令人兴奋的活动，会加剧对错过愉快经历的恐惧。\n\n2. **比较和焦虑：** FoMO 患者经常将自己的生活与社交媒体上的精彩片段进行比较。这种不断的比较会让人产生不满足感、焦虑感和落伍感。\n\n3. **持续连接：** 智能手机的普及和持续连接加剧了 FoMO。能够即时分享和接收有关活动或社交聚会的最新信息，加剧了对错过最新事件的恐惧。\n\n4. **对幸福感的影响：** FoMO 可能对心理健康和幸福感产生负面影响。它可能会导致压力、焦虑和不断需要保持联系或参与各种活动以避免错过的恐惧。\n\n为了应对 FoMO，个人可以考虑以下方法：\n\n- 正念：在当下的时刻，欣赏自己的经历，而不是不断比较。\n\n- 优先排序：认识并优先排序符合个人价值观和目标的活动。\n\n- 数字排毒：从社交媒体和数字设备中抽身出来，以减少持续不断的信息流和比较。\n\n了解并解决 FoMO 的根本原因，有助于建立更健康的心态，改善整体福祉。\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 58,
        "thumbNum": 4,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-28T10:14:51.000+00:00",
        "updateTime": "2024-02-19T08:52:00.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "admin",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 40,
          "coin": 0,
          "followeeNum": 15,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-04-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2024-02-04T08:45:43.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1750478959709003778",
        "title": "年少不知 Base 好，错把总包当成宝。。",
        "description": null,
        "content": "\n\n今天聊一个很现实的话题：选 offer 对比薪资时，我强烈建议以 Base 为主，而不是总包。\n\n为什么？且听鱼皮娓娓道来。\n\n**注意，以下为个人观点，仅供参考！**\n\n首先明确 Base 和总包的概念：\n\nBase：是指合同规定的最基本 **底薪**，一般不包括奖金、福利或其他附加条件，也不会受绩效的影响。单位一般是月，我们常说的月薪 1 万、月薪 2 万，通常是指 Base。\n\n总包：是指工作所得的所有价值的总和，除了底薪之外，还有奖金、五险一金、股票期权、培训津贴、住房补贴等。单位一般是年，我们常说的 package 10 万、年包 20 万通常是指总包。\n\n为啥我强烈建议大家更关注 Base，而不是看总包呢？那必然和我的个人经历有关。\n\n![](https://pic.yupi.icu/1/image-20240104140859209.png)\n\n我 19 年实习转正加入腾讯，20 年正式入职，当时腾讯的薪资是非常有竞争力的（现在也很有竞争力）。\n\n这里解释一下大厂的薪资构成，通常为：Base * 月数 + 绩效奖金 + 股票 / 期权 + 其他福利 + 一次性签字费。\n\n我的领导很看重我，为我争取到了本科生最高的 Base 和总包，当时我是满心欢喜的，大恩大德没齿难忘。\n\n但是，现在回想起来，还是有点天真了。为啥？\n\n因为当时鹅的 Base 并不高，总包高基本都是靠股票和绩效奖金撑的。\n\n薪资是敏感内容，所以我就用 **示例数据** 给大家举个例子：\n\n- 方案 A：Base 2 万 / 月 *（20 个月）+ 10 万股票（分 2 年给）+ 一次性签字费 5 万 = 55 万\n- 方案 B：Base 3 万 / 月 *（12 个月）+ 4 万股票（1 年给完） = 40 万\n\n大家会选哪个？\n\n以前我肯定选 A，但现在我会犹豫一下，有可能会选择 B。\n\n因为方案 A 虽然总包高，但是充满了不确定性。这个不确定性主要体现在 2 方面：\n\n1）浮动绩效奖金：比如一年发 20 个月的薪资，其实是蕴藏了绩效因素的，有 8 个月的浮动绩效奖金。如果部门和个人绩效好，可能给你多发 8 个月年终；而如果部门或个人绩效不好，可能 1 个月年终都没有，那总包直接崩盘！\n\n> 不过有些公司的合同上会给应届生承诺不低于多少个月的绩效奖金，具体情况具体分析。\n\n2）股票：股票和期权其实都是不稳定的。就拿我这倒霉蛋来说吧，20 年的时候，总包高基本都是靠股票撑起来的。没记错的话，当时腾讯的股价是 450 左右吧，22 年的时候突然涨到 700 多，当时我乐疯了，然而发现得等股票解禁才能卖。。。结果现在，腾讯的股票在 200 多、300 多左右浮动，直接亏了 1 / 3 都不止！\n\n![](https://pic.yupi.icu/1/image-20240104142528202.png)\n\n而如果是没上市公司承诺给期权，也要掂量掂量公司的发展情况和可能的市值，不要被单方面画饼。\n\nBase 高还有一个很大的好处 —— 涨薪潜力大。很多公司的涨薪幅度是基于 Base 薪资计算的，比如之前行情好的时候流传的跳槽涨薪 30%、50%，更多的是基于 Base。Base 越高，未来的薪资涨幅可能就越大。\n\n对应届生来说，Base 薪资也是基本的生活来源，像奖金、股票、期权的不确定性太大。像我在腾讯的时候，公司有时候会在晋升时发发股票，但都是分成 3 - 4 年才能给完，谁能保证自己在这家公司干多久呢？我的股票到现在还没卖出去呢（\n\n所以其实之前我跟大厂朋友们交流的时候，一直吐槽 “年少不知 Base 好，错把总包当成宝”。\n\n现在看来，到手的钱才是钱，base 高才是真的香。\n\n![](https://pic.yupi.icu/1/image-20240104144131479.png)\n\n当然，具体情况具体分析，对不打算和公司绑定的应届生来说，关注 Base、公司潜力和个人发展是最重要的；但对于工作多年、追求稳定、尤其是在公司有一定地位的老员工来说，总包会更重要一些，因为你在这一家公司工作越久，拿到的股票 / 期权就会越多，越能证明自己的价值。\n\n但不管是什么情况，只要提到股票 / 期权授予，就要了解清楚授予机制、公司发展、变现机制、税收影响等等。\n\nOK，就分享到这里，分享我自己的故事，希望大家有收获。\n\n\n\n ",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/cAo6eVSz-640 (10).png",
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 74,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-25T11:21:20.000+00:00",
        "updateTime": "2024-02-19T07:46:59.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3020,
          "coin": 170,
          "followeeNum": 1383,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2286-11-20T17:46:39.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2024-02-19T08:46:55.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1750409573761556481",
        "title": "NVM管理Node版本-Win版",
        "description": "在Windows环境中安装NVM对不同的Node版本进行管理，同时提供npm和yarn包管理器常用配置。",
        "content": "# NVM管理Node版本\n\n> 环境：win11\n> 注意：^标识为推荐掌握\n\n## 1、下载NVM\n\n**1、下载的是免安装版**`nvm-noinstall.zip`，版本号为：`1.1.12`\n\n![image-20240104140257567](https://cdn.jsdelivr.net/gh/yovvis/pic@main/24/202401041402621.png)\n\n**免安装版本是没有settings文件的**\n\n![image-20240125090250706](https://cdn.jsdelivr.net/gh/yovvis/pic@main/24/202401250902976.png)\n\n**需要加一个**`settings.txt`文件，下方配置可以自行修改\n\n```\nroot: D:\\envs\\nvm\npath: D:\\envs\\nvm\\nodejs\nnode_mirror: https://npmmirror.com/mirrors/node/\nnpm_mirror: https://npmmirror.com/mirrors/npm/\n```\n\n1. **root**\n   **解压缩nvm的路径**\n2. **path**\n   **要安装nodejs的路径**\n3. **node\\_mirror**\n   **node镜像源 可替换为taobao的**\n4. **npm\\_mirror**\n   **npm镜像源 可替换为taobao的**\n\n## 2、配置系统参数\n\n**系统变量**`比对settings.txt`文件的的root和path\n\n```\nNVM_HOME \nD:\\envs\\nvm\n​\nNVM_SYMLINK \nD:\\envs\\nvm\\nodejs\n```\n\n**环境路径（没有安装yarn就不需要配yarn的相关配置）**\n\n```\n%NVM_HOME%\n​\n%NVM_SYMLINK%\n​\n-- 如果配置了第5点和第6点需要新加下面配置，yarn的配置路径需要具体到bin\nD:\\envs\\nvm\\node_global\nD:\\envs\\nvm\\yarn_global\\bin\n```\n\n***ps（提醒）：***\n\n* **up的prefix和folder是放在同一目录的，请各位酌情而定，具体为啥给出上述配置，相信看到第五步和第六步的可以理解；**\n* **这里先给出node和yarn的全局安装目录的路径，仅起强调作用，具体的路径需看实际情况，有的uu喜欢放在C盘。**\n\n**这里给上up的环境变量配置**\n\n**1、系统变量**\n\n![image-20240125092536829](https://cdn.jsdelivr.net/gh/yovvis/pic@main/24/202401250925886.png)\n\n**2、环境配置**\n\n![image-20240125094053376](https://cdn.jsdelivr.net/gh/yovvis/pic@main/24/202401250940434.png)\n\n## 3、安装Node\n\n**指定版本号安装（推荐使用）**\n\n```\nnvm install 18.16.0\n```\n\n**查看可安装版本（常用，在想安装之前执行一下）**\n\n```\nnvm list available\n```\n\n`^`安装最新版本（不推荐）\n\n```\nnvm install latest\n```\n\n`^`安装最新LTS版本（不常用）\n\n```\nnvm install lts\n```\n\n`删除某个版本Node`\n\n```\nnvm uninstall 16.20.1\n```\n\n***切换Node版本***\n\n**查看已安装的Node版本**\n\n```\nnvm ls\n```\n\n**使用某个版本Node，并查看**\n\n```\nnvm use 18.16.0\n```\n\n![image-20240104141248132](https://cdn.jsdelivr.net/gh/yovvis/pic@main/24/202401250922199.png)\n\n**yes，成功！**\n\n## 4、修改npm路径\n\n***ps：默认是在C盘下，不介意全在C盘可以不配置***\n\n```\nnpm config set prefix \"D:\\envs\\nvm\\node_global\"\nnpm config set cache \"D:\\envs\\nvm\\node_cache\"\n```\n\n`^`查看全局命令\n\n```\nnpm prefix -g \nnpm config ls\n```\n\n**执行**`npm config ls`，得到配置如下\n\n![image-20240104141039937](https://cdn.jsdelivr.net/gh/yovvis/pic@main/24/202401041410993.png)\n\n## 5、修改yarn配置\n\n***ps：默认是在C盘下，不介意全在C盘可以不配置,***\n\n***安装yarn之前务必确认第五步需不需要，再检查有没有配置环境变量***\n\n**全局安装yarn**\n\n```\nnpm install yarn -g\n```\n\n**配置yarn路径（不配置yarn安装的包会在C盘下，不介意可以不配）**\n\n```\nyarn config set prefix \"D:\\envs\\nvm\\yarn_global\"\nyarn config set global-folder \"D:\\envs\\nvm\\yarn_global\"\nyarn config set cache-folder \"D:\\envs\\nvm\\yarn_cache\"\n```\n\n`^`关闭代理服务器访问（可以不配，如果yarn安装包报证书失效可以执行）\n\n```\nyarn config set \"strict-ssl\" false -g\n```\n\n`^`查看yarn目录\n\n```\nyarn global bin\nyarn global dir\nyarn cache dir\n```\n\n`^`查看配置命令\n\n```\nyarn config list\n```\n\n**执行**`yarn config list`，配置如下\n\n![image-20240104141210211](https://cdn.jsdelivr.net/gh/yovvis/pic@main/24/202401041412264.png)\n\n## 6、检查nvm文件夹\n\n**最后的最后，如果就是检查一下**\n\n* **我们npm全局安装的在node\\_global下**\n* **我们yarn全局安装的在yarn\\_global下（在本目录或者下一级的bin目录中）**\n\n![image-20240125092719833](https://cdn.jsdelivr.net/gh/yovvis/pic@main/24/202401250927879.png)\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1658284526012526594/HS7AUvVV-202401041341588.webp",
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 32,
        "thumbNum": 2,
        "favourNum": 2,
        "commentNum": 1,
        "priority": 0,
        "userId": "1658284526012526594",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-25T06:45:38.000+00:00",
        "updateTime": "2024-02-19T08:35:25.000+00:00",
        "user": {
          "id": "1658284526012526594",
          "planetCode": "22369",
          "userName": "22369-Yovvis",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/ftW1ZribibiclC2h68L8Knd9yf8klWdUiblpZhLrJiclLd2GibgatGe02U0XnEkT9AbekGAEaTicxDQeic3V1UhCCGurdw/132",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": "2000-07-02",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-05-12T10:44:37.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-05-16T01:33:35.000+00:00",
          "updateTime": "2024-02-01T18:11:55.000+00:00"
        },
        "tags": [
          "文章",
          "前端",
          "教程"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1750117490454700034",
        "title": "写了7年代码，第一次见这么狗血的小Bug！",
        "description": null,
        "content": "大家好，我是程序员鱼皮。\n\n\n\n## 孽起\n\nBug 年年有，今年特别多。前段时间给大家分享过一个 [特别坑的小 Bug](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247543723&idx=1&sn=3db0d0bcf9311f7f77c73bd35005515b&chksm=e9c2cc5cdeb5454abe0a9ac6dccbeaa80e9dc540f34f05bbc49f0b92f9be3ca63c6c5fc25c38&token=1338241026&lang=zh_CN#rd)，结果这两天我个倒霉蛋又遇到一个特别离谱的 Bug，有多离谱？大家可以看看视频：https://www.bilibili.com/video/BV1Fc411y7HS\n\n![](https://pic.yupi.icu/1/image-20231226143658269.png)\n\n官方省流：我的后端 Spring Boot 项目在 8101 端口启动，启动后可以访问 `localhost:8101/api/v3/api-docs` 得到接口文档的 JSON 数据，我的前端需要这份数据来生成请求代码。\n\n![](https://pic.yupi.icu/1/image-20231226143733821.png)\n\n结果呢，生成一直错误。经过一番排查，我发现前端没有正确获取到 JSON 数据，而是得到了一个 hello world 字符串。\n\n![](https://pic.yupi.icu/1/image-20231226143824050.png)\n\n这一下子给我整懵了，hello world 哪来的？\n\n![](https://pic.yupi.icu/1/image-20231226143927066.png)\n\n于是我就打开浏览器，访问地址：`127.0.0.1:8101/api/v3/api-docs` ，结果竟然返回了 hello world！\n\n![](https://pic.yupi.icu/1/image-20231226144025518.png)\n\n奇怪了，我的后端程序可没有输出 hello world 的代码呀。于是我通过命令查看哪些程序占用了 8101 端口：\n\n![](https://pic.yupi.icu/1/image-20231226144136731.png)\n\n哦，原来是一个叫 aDrive 的程序也占用了 8101 端口！\n\n这是一个知名的网盘软件，只要在 MAC 电脑上运行它，你访问本地的 8101 端口就能看到 hello world 了。\n\n看到这，真是让我哭笑不得，没想到我自己做项目时用的端口号竟然和别的程序冲突了。\n\n话说为啥要占用这个端口来输出 hello world 啊，测试代码忘删了么？\n\n![](https://pic.yupi.icu/1/image-20231226144219307.png)\n\n好了，Bug 大概介绍到这，接下来讲点小知识。\n\n\n\n## 小知识\n\n在很多同学的认知中：\n\n1）同一个端口只能被一个程序占用。\n\n> 或者说：同一个端口只能启动 1 个 Tomcat，否则就会冲突。\n\n2）访问 localhost 和访问 127.0.0.1 得到的响应是一致的。\n\n\n\n我说的没错吧？\n\n有这些认识很正常，很多工作多年的大佬如果没经历过这样的 Bug，也会这么认为。\n\n但其实这 2 个认识都是错误的。\n\n\n\n#### 1、同一个端口只能被一个程序占用？\n\n这句话缺少了重要的条件。不同的网络协议是可以共享同一端口的。\n\n比如我这次遇到的情况是，aDrive 和我的后端程序使用的网络协议不同，分别为 IPv4 和 IPv6，所以并不会冲突。\n\n![](https://pic.yupi.icu/1/image-20231226144556366.png)\n\n同理，TCP 和 UDP 作为两种不同的传输层协议，也可以使用相同的端口号。\n\n\n\n#### 2、localhost 不等于 127.0.0.1\n\n首先，`localhost`  和 `127.0.0.1`  完全是两个不同的概念！\n\nlocalhost 是 **主机名** （hostname），它通常被用来表示本地计算机，并且默认被解析到 127.0.0.1 这个地址。\n\n但是你只要修改主机文件（hosts），就可以把 localhost 解析到其他地址，跟域名解析类似。\n\n而 127.0.0.1 是 IPv4 的一个特殊的 **IP 地址**，直接指向本地回环接口，用于在本地进行网络通信。\n\n为了兼容 IPv4 和 IPv6，我们访问 localhost 时，操作系统会首先尝试解析 IPv6 的回环地址 `::1` 。如果系统不支持 IPv6，或者无法解析为 IPv6 地址，才会继续解析为 IPv4 的回环地址 127.0.0.1。\n\n而直接访问 127.0.0.1 时，系统会默认解析到 IPv4 的回环接口。这才导致输入这两个地址时，使用的服务 / 访问到的内容不一样。\n\n\n\n---\n\n\n\nok，就是这样一个小 bug，也能学到很多的知识，希望有用，学会还请点个赞吧～\n\n![](https://pic.yupi.icu/1/640.png)",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/vW4q6VBi-640 (17).jpeg",
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 76,
        "thumbNum": 6,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-24T11:24:59.000+00:00",
        "updateTime": "2024-02-19T07:47:43.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3020,
          "coin": 170,
          "followeeNum": 1383,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2286-11-20T17:46:39.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2024-02-19T08:46:55.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "1683",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "211"
  },
  "message": "ok"
}